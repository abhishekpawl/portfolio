
*VM's not included in syllabus*

---

# Azure VM

## Creating a VM in Powershell

```shell
> New-AzResourceGroup -Name 'pwrsgroup' -Location 'EastUS'
> New-AzVM -ResourceGroup 'pwrsgroup' -Location 'EastUS' -Name 'pwrsdemo' -PublicIpAddressName 'myPublicIP' -OpenPort 80,443,3389
```

## Creating a VM in CLI

```bash
> az group create --name cligroup --location eastus
> az vm create --resource-group cligroup --name aznewvm --image win2022datacenter --admin-username azsjdtestuser
```

*default VM size Azure wants to use while creating a VM*
- Standard DS1

# Azure App Service

- Platform as a Service (PaaS)
- computing platform
- abstraction on top of a VM that gives us a lot of tools to develop and deploy applications on the cloud
- FTP files into the App Service
- load balancer built into it
- **Deployment Slots**
	- in the S1 production plan
	- we can create a different deployment slot, other than the production and maybe test our code in that deployment slot without affecting the prod code
	- safe deployment - *swap*
- **ARR affinity setting**
	- force traffic to go into the same server from the same user

---

# Azure App Service

## Creating a Web App in PowerShell
- create a resource group
```powershell
> New-AzResourceGroup -Location 'EastUS' -Name 'powershellwebapp'
```
- app service have two components
	- app service plan
		- host of the web app
	- web app
- create an app service plan
```powershell
> New-AzAppServicePlan -Name 'aznewappserviceplan123' -Location 'EastUS' -ResourceGroupName 'powershellqwebapp' -Tier Free
```
- create a web app into the app service plan
```powershell
> New-AzAWebApp -ResourceGroupName 'powershellwebapp' -Name 'apnewwebapp11223344' -Location 'EastUS' -AppServicePlan 'aznewappserviceplan'
```

## Creating a Web App in CLI
- create a new group
```bash
$ az group create --name cliwebapp --location eastus
```
- two components
	- app service plan
	```bash
	$ az appservice plan create -g cliwebapp -n mynewasp123
	```
	- web app
	```bash
	$ az webapp create -g cliwebapp -n apnewwebapp2 -p mynewasp123
	```

## Easier way to create a Web App
- in the code repo folder
```bash
$ az webapp up --location eastus --name apnewwebapp1122289 --html
```

---

# Containers

- simplest form - container instances

## Container Instances
- **simplest way to deploy containers**
	- not suited for production scenarios
- **burstable scaling feature** for Azure Kubernetes service(AKS)
- support availability zones
- image sources
	- quickstart images
	- Azure Container Registry
	- other registry

## Container Registry
- directory for our private container images
- deploying Azure Container Instance from Azure Container Registry
- deploying Azure Web App from Azure Container Registry
---

# Azure Functions

- run small pieces of code, hosted in the cloud
- integrations
	- trigger
	- input bindings
	- output bindings

## HTTP Trigger function
- *index.js*
```js
module.exports = async function (context, req) {
	context.log('JavaScript HTTP trigger function processed a request');
	const name = (req.query.name || (req.body && req.body.name));
	const responseMessage = name
		? "Hello, " + name + ". This HTTP triggered function executed successfully."
		: "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body.";
	context.res = {
		// status: 200. /* defaults to 200 */
		body: responseMessage
	};
}
```
- *function.json*
```json
{
	"bindings": [
		{
			"authLevel": "function",
			"type": "httpTrigger",
			"direction": "in",
			"name": "req",
			"methods": [
				"get",
				"post"
			]
		},
		{
			"type": "http",
			"direction": "out",
			"name": "res"
		}
	]
}
```

## Monitoring function events and errors
- monitor tab in function
- can enable application insights
- realtime logging system

## Adding a Blob Output Binding
- define a out container path, where the blob will be stored
```js
// index.js file 0 modification
	context.bindings.outputBlob = name;
```

## Timer Trigger function
- define schedule - cron format
- *index.js*
```js
module.exports = async function (context, myTimer) {
	var timestamp = new Date().toISOString();
	if(myTimer.isPastDue) {
		context.log('JavaScript is running late!');
	}
	context.log('JavaScript timer trigger function ran!'. timestamp);
}
```
- *function.json*
```json
{
	"bindings": [
		{
			"authLevel": "anonymoud", // the function does not need a sec token
			"name": "myTimer",
			"type": "timerTrigger",
			"direction": "in",
			"schedule": "0 */5 * * * *"
		}
	]
}
```

# Properties: Azure Functions (so far)
- serverless design
- simple
- stateless
- short-lived : start, do work, stop
- triggered by a timer, http request, blob event, or message queue
- best designed to work asynchronously with other code

*functions are designed to a do a specific task in quickest way possible*

*azure functions have a timeout of 30 mins*

*so for longer running tasks -* **Azure Durable Functions**

# Properties: Azure Durable Functions
- stateful
- could be long-running
- or a multi-step process
- can *suspend* while waiting for a long-running API to return - **checkpoints**
- supports complex design patterns
- functions can call other functions - **chaining**
- made up of a client, orchestrator and activities

## Client
- the original triggered function
- typically sets up the orchestrator
- gets the orchestrator running

## Orchestrator
- the traffic cop
- logic app - metaphor
- code - workflow

## Activity
- basic unit of work of a function
- does the work
	- create a file
	- call an API
	- perform some task

## Architecture patterns
- **Function Chaining Pattern**
	- F1 -> F2 -> F3 -> F4
- **Fan out / Fan in Pattern**
	- F1 -> F2 (\*3 child functions in parallel) -> F3
	- these three functions (F2) can have different execution lengths
	- it will wait for all 3 functions to finish
- **Asynchronous API Pattern**
	- *GetStatus* event that's going to trigger every once in a while to make sure the work is done and then it can continue
- **Monitor Pattern**
	- function waiting for something to happen
- **Human Interaction Pattern**
	- need for a person to come in and, say, click on a button
	- we can have a function waiting on that approval

*adding delays to function - npm module - moment*

---

# Storage Accounts

*mainly Blob storage, and not managed disks*

## Managed Disk
- managed storage accounts
- with a service built on top of the premium or the standard storage options
- reserve for a certain amount
- we get charged whether we use the storage or not

## Blob storage
- cheapest option
- tiers
	- premium
	- hot
	- cool
	- archive
- pricing varies by region
- 2 URL's
	- primary read & write URL
	- secondary read-only URL
- *Network routing*
	- Microsoft network routing
		- travel inside Microsoft's private network
		- the amount of time spent in the public internet is minimised
		- charged by Microsoft
	- Internet routing
- *Data protection*
	- **soft delete**
		- marked for deletion and then deleted after a certain number of days
		- protection against accidental deletions or malicious intentional deletions
	- tracking
		- versioning
		- change feed - (notifications)
- *Encryption*
	- Microsoft-managed keys
	- Customer-managed keys
	- infrastructure encryption
		- second layer of encryption between the Azure service and the physical disc

## Access keys
- Microsoft provides 2 keys
- these keys give full administrative access to storage account
- connection strings
	- use within programs to access the storage account

*share access without sharing the keys - SAS (Shared Access Signature)*

## SAS
- this access can not be revoked directly
- to revoke access - *regenerate the signing key*
- to revoke access - *Stored access policy*

## AzCopy V10
- to move files between containers or storage accounts
- command-line utility
- can work with
	- Azure Active Directory credentials for blob storage
	- SAS token
	- Azure files
	- Amazon S3
	- Google Cloud Storage
	- Azure Stack storage
```shell
azcopy copy '<source url - SAS token URL>' '<destination URL - SAS token URL>'
```

## StartCopyFromUri method
- Azure Storage SDK
- components (code)
	- connection string
	- source container
	- destination container
	- source file
	- destination file\
	- source client `sourceclient = new BlockBlobClient(connectionstring, sourcecontainer, sourcefile)`
	- destination client
```cs
destclient.StartCopyFromUri(sourceclient.Uri);
```

## SetMetaData method
- getting and retrieving properties
```cs
BlobProperties properties = sourceclient.GetProperties();
```
- to set metadata
```cs
IDictionary<string, string> metadata = new Dictionary<string, string>();
metadata.Add("CreatedBy", "Scott Duffy");
metadata["environment"] = "development";
sourceclient.SetMetaData(metadata);
```

## Storage Account Backup, Replication and Lifecycle
- backup vault
- backup policy - (frequency)
- object replication
- lifecycle management
	- rule that will move files from the hot tier to the cool tier or to the archive tier based on the last access date